<template>
  <Teleport to="body">
    <div class="sidebar-wrapper" v-if="sidebarStore.isOpen" :style="{ width: `${sidebarWidth}px` }">
      <div class="resize-handle" @mousedown="startResize"></div>
      <div class="sidebar-header">
        <h2>{{ $t('sidebar.assistant.title') }}</h2>
        <div class="header-actions">
          <button class="action-btn interactive-element" @click="clearHistory" title="Ê∏ÖÁ©∫ÂØπËØùÂéÜÂè≤">
            <span v-html="iconDelete"></span>
          </button>
          <button class="close-btn interactive-element" @click="sidebarStore.closeSidebar">
            <span v-html="iconClose"></span>
          </button>
        </div>
      </div>
      <div class="chat-container">
        <div class="chat-messages" ref="chatMessagesRef">
          <div
            v-for="(message, index) in chatMessages"
            :key="index"
            :class="['message', message.role === 'user' ? 'user-message' : 'ai-message']"
          >
            <div class="message-avatar">
              <div class="avatar-icon">
                {{ message.role === 'user' ? 'üë§' : 'ü§ñ' }}
              </div>
            </div>
            <div class="message-content">
              <div class="message-header">
                <div class="sender-info">
                  <span class="message-sender">{{
                    message.role === 'user' ? 'You' : $t('sidebar.assistant.title')
                  }}</span>
                  <div
                    v-if="getMessageStatus(message)"
                    class="status-indicator"
                    :class="getMessageStatus(message)"
                  >
                    <!-- Ê≠£Âú®ÁîüÊàê -->
                    <template v-if="getMessageStatus(message) === 'generating'">
                      <span class="status-icon typing" v-html="iconTyping"></span>
                      <span class="status-text">Ê≠£Âú®ÁîüÊàê</span>
                    </template>

                    <!-- Ê≠£Âú®ËøõË°åÂ∑•ÂÖ∑Ë∞ÉÁî® -->
                    <template v-else-if="getMessageStatus(message) === 'tool-calling'">
                      <span class="status-icon spinning" v-html="iconSpinner"></span>
                      <span class="status-text">Ê≠£Âú®‰ΩøÁî®Â∑•ÂÖ∑</span>
                    </template>

                    <!-- Â∑•ÂÖ∑Ë∞ÉÁî®ÂÆåÊàê -->
                    <template v-else-if="getMessageStatus(message) === 'tool-completed'">
                      <span class="status-icon" v-html="iconCheck"></span>
                      <span class="status-text">Â∑≤‰ΩøÁî®Â∑•ÂÖ∑</span>
                    </template>
                  </div>
                </div>
                <span class="message-time">{{ message.time }}</span>
              </div>

              <!-- ÂõæÁâáÊ∂àÊÅØ -->
              <div v-if="message.hasImage" class="message-image">
                <div v-if="message.images && message.images.length > 1" class="image-grid">
                  <div v-for="(img, idx) in message.images" :key="idx" class="image-container">
                    <img :src="img" alt="Áî®Êà∑‰∏ä‰º†ÂõæÁâá" class="message-img" />
                    <div class="image-overlay">
                      <button
                        class="image-action-btn expand-btn"
                        @click="expandImage(img)"
                        title="Êü•ÁúãÂ§ßÂõæ"
                      >
                        <span v-html="iconExpand"></span>
                      </button>
                      <div class="top-right-actions">
                        <button
                          class="image-action-btn"
                          @click="selectExistingImage(img || '')"
                          title="Ê∑ªÂä†Âà∞ËæìÂÖ•"
                        >
                          <span v-html="iconPlus"></span>
                        </button>
                        <button
                          class="image-action-btn"
                          @click="downloadImage(img || '')"
                          title="‰∏ãËΩΩÂõæÁâá"
                        >
                          <span v-html="iconDownload"></span>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
                <div v-else class="image-container">
                  <img :src="message.image" alt="Áî®Êà∑‰∏ä‰º†ÂõæÁâá" class="message-img" />
                  <div class="image-overlay">
                    <button
                      class="image-action-btn expand-btn"
                      @click="expandImage(message.image)"
                      title="Êü•ÁúãÂ§ßÂõæ"
                    >
                      <span v-html="iconExpand"></span>
                    </button>
                    <div class="top-right-actions">
                      <button
                        class="image-action-btn"
                        @click="selectExistingImage(message.image || '')"
                        title="Ê∑ªÂä†Âà∞ËæìÂÖ•"
                      >
                        <span v-html="iconPlus"></span>
                      </button>
                      <button
                        class="image-action-btn"
                        @click="downloadImage(message.image || '')"
                        title="‰∏ãËΩΩÂõæÁâá"
                      >
                        <span v-html="iconDownload"></span>
                      </button>
                    </div>
                  </div>
                </div>
                <!-- <div
                  v-if="
                    message.role === 'assistant' &&
                    sidebarStore.nodeInfo &&
                    canApplyToNode(sidebarStore.nodeInfo) &&
                    !serverMode
                  "
                  class="image-actions"
                >
                  <button
                    class="apply-to-node-btn"
                    @click="applyImageToNode(message.image)"
                    :title="getNodeActionTitle(sidebarStore.nodeInfo)"
                  >
                    {{ getNodeActionText(sidebarStore.nodeInfo) }}
                  </button>
                </div> -->
              </div>

              <!-- Â∑•ÂÖ∑Ë∞ÉÁî®ÂâçÁöÑÂÜÖÂÆπ -->
              <div
                v-if="message.preToolContent"
                class="message-text pre-tool-content"
                v-html="message.preToolContent"
              ></div>

              <!-- Ê≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®Êó∂ÁöÑÂÆåÊï¥ÂÜÖÂÆπ -->
              <div
                v-else-if="!message.toolName"
                class="message-text"
                v-html="message.content"
              ></div>

              <!-- Â∑•ÂÖ∑Ë∞ÉÁî®‰∏éÁªìÊûú -->
              <div v-if="message.toolName" class="tool-section">
                <div class="tool-header">
                  <span class="tool-title">Ë∞ÉÁî®Â∑•ÂÖ∑: {{ message.toolName }}</span>
                  <button
                    class="tool-args-toggle interactive-element"
                    @click="toggleToolArgs(message)"
                  >
                    {{ message.showToolArgs ? 'ÈöêËóèÂèÇÊï∞' : 'ÊòæÁ§∫ÂèÇÊï∞' }}
                  </button>
                </div>
                <div v-if="message.showToolArgs" class="tool-args">
                  <pre class="code-block"><code>{{ message.toolCallArgs }}</code></pre>
                </div>

                <div v-if="message.toolResultText && !message.hasImage" class="tool-result">
                  <div class="tool-result-label">Â∑•ÂÖ∑ÁªìÊûú:</div>
                  <pre class="code-block"><code>{{ message.toolResultText }}</code></pre>
                </div>
              </div>

              <!-- Â∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπ -->
              <div
                v-if="message.postToolContent"
                class="message-text post-tool-content"
                v-html="message.postToolContent"
              ></div>
            </div>
          </div>
          <div v-if="isLoading" class="loading-indicator">
            <div class="loading-text">{{ processingStatus }}</div>
            <div class="loading-dots">
              <div class="dot"></div>
              <div class="dot"></div>
              <div class="dot"></div>
            </div>
          </div>
        </div>
        <!-- ËæìÂÖ•Âå∫Âüü -->
        <div class="chat-input-area">
          <div v-if="sidebarStore?.nodeInfo" class="node-info-card">
            <div class="node-info-header">
              <span v-html="iconLayers"></span>
              <span class="node-info-title">ÂΩìÂâçËäÇÁÇπ</span>
            </div>
            <div class="node-info-main">
              <div class="node-info-content">
                <div class="info-item">
                  <span class="label">{{ $t('sidebar.assistant.nodeName') }}</span>
                  <span class="value">{{ sidebarStore.nodeInfo.title }}</span>
                </div>
                <div class="info-item">
                  <span class="label">{{ $t('sidebar.assistant.nodeType') }}</span>
                  <span class="value">{{ sidebarStore.nodeInfo.type }}</span>
                </div>
              </div>
              <div v-if="sidebarStore.nodeInfo.imageInfo?.url" class="node-image-preview">
                <img
                  :src="sidebarStore.nodeInfo.imageInfo.url"
                  alt="ËäÇÁÇπÂõæÁâá"
                  class="node-preview-img"
                  @click="expandImage(sidebarStore.nodeInfo.imageInfo.url)"
                />
              </div>
            </div>
          </div>
          <div class="image-preview-area" v-if="previewImage">
            <div class="preview-image-container">
              <img :src="previewImage" alt="ÂõæÁâáÈ¢ÑËßà" class="preview-image-small" />
              <button class="remove-image-btn" @click="removeImage">√ó</button>
            </div>
          </div>

          <div class="input-controls">
            <button
              class="upload-image-btn interactive-element"
              @click="triggerImageUpload"
              :disabled="isLoading"
              :title="$t('sidebar.assistant.uploadImage')"
            >
              <span v-html="iconImage"></span>
            </button>

            <div class="textarea-container interactive-element">
              <textarea
                class="interactive-element"
                v-model="userInput"
                :placeholder="$t('sidebar.assistant.inputPlaceholder')"
                @keydown.enter="handleKeyDown"
                ref="textareaRef"
                :disabled="isLoading"
              ></textarea>
            </div>

            <!-- ÂèëÈÄÅ/ÂÅúÊ≠¢ÊåâÈíÆÂêàÂπ∂ -->
            <button
              class="send-stop-btn interactive-element"
              @click="isGenerating ? abortGeneration() : sendMessage()"
              :disabled="!isGenerating && !canSendMessage"
              :title="isGenerating ? 'ÂÅúÊ≠¢ÁîüÊàê' : $t('sidebar.assistant.sendMessage')"
            >
              <span v-if="!isGenerating" v-html="iconSend"></span>
              <span v-else v-html="iconStop"></span>
            </button>
          </div>

          <input
            type="file"
            ref="imageInputRef"
            style="display: none"
            accept="image/*"
            @change="handleImageUpload"
          />
        </div>
      </div>
    </div>

    <!-- ÂõæÁâáÊü•ÁúãÂºπÁ™ó -->
    <div class="image-modal" v-if="showImageModal" @click="closeImageModal">
      <div class="modal-content" @click.stop>
        <img :src="modalImageSrc" alt="Â§ßÂõæÊü•Áúã" class="modal-image" />
        <button class="modal-close-btn" @click="closeImageModal">√ó</button>
      </div>
    </div>
  </Teleport>
</template>

<script setup lang="ts">
  import { useSidebarStore } from '../../stores/sidebarStore'
  import { onMounted, watch, ref, computed, onBeforeUnmount, nextTick } from 'vue'
  import {
    sendStreamChatRequest,
    formatOutputTextLight,
    formatOutputText,
    convertToApiHistory
  } from './util'
  import { useI18n } from 'vue-i18n'
  import { useToaster } from '@/components/modules/toats/index'
  import { v4 as uuidv4 } from 'uuid'
  import { downloadImage } from '@/utils/tool'
  import { useServerModeStore } from '@/stores/isServerMode'
  import { imageToOss, base64ToFile } from '@/components/modules/vUpload/imageToOss'
  import './Sidebar.css'
  // icons
  import iconDelete from '@/assets/icons/delete.svg?raw'
  import iconClose from '@/assets/icons/close.svg?raw'
  import iconTyping from '@/assets/icons/typing.svg?raw'
  import iconSpinner from '@/assets/icons/spinner.svg?raw'
  import iconCheck from '@/assets/icons/check.svg?raw'
  import iconExpand from '@/assets/icons/expand.svg?raw'
  import iconPlus from '@/assets/icons/plus.svg?raw'
  import iconDownload from '@/assets/icons/download.svg?raw'
  import iconLayers from '@/assets/icons/layers.svg?raw'
  import iconImage from '@/assets/icons/image.svg?raw'
  import iconSend from '@/assets/icons/send.svg?raw'
  import iconStop from '@/assets/icons/stop.svg?raw'
  const { t } = useI18n()
  const sidebarStore = useSidebarStore()

  // ‰æßËæπÊ†èÂÆΩÂ∫¶Áõ∏ÂÖ≥ÂèòÈáè
  const sidebarWidth = ref(550) // ÈªòËÆ§ÂÆΩÂ∫¶
  const minWidth = 50 // ÊúÄÂ∞èÂÆΩÂ∫¶
  const maxWidth = 1300 // ÊúÄÂ§ßÂÆΩÂ∫¶
  const isResizing = ref(false)

  // ÂºÄÂßãÊãñÊãΩ
  const startResize = (e: MouseEvent) => {
    isResizing.value = true
    document.addEventListener('mousemove', handleResize)
    document.addEventListener('mouseup', stopResize)
    // Èò≤Ê≠¢ÈÄâ‰∏≠ÊñáÊú¨
    e.preventDefault()
  }

  const handleResize = (e: MouseEvent) => {
    if (!isResizing.value) return

    // ËÆ°ÁÆóÂÆΩÂ∫¶ (Á™óÂè£ÂÆΩÂ∫¶ - Èº†Ê†á‰ΩçÁΩÆ)
    const newWidth = window.innerWidth - e.clientX

    // ÈôêÂà∂ÂÆΩÂ∫¶ËåÉÂõ¥
    if (newWidth >= minWidth && newWidth <= maxWidth) {
      sidebarWidth.value = newWidth
      // ‰øùÂ≠òÂÆΩÂ∫¶Âà∞Êú¨Âú∞Â≠òÂÇ®
      localStorage.setItem('bizyair-sidebar-width', newWidth.toString())
    }
  }

  // ÂÅúÊ≠¢ÊãñÊãΩ
  const stopResize = () => {
    isResizing.value = false
    document.removeEventListener('mousemove', handleResize)
    document.removeEventListener('mouseup', stopResize)
  }

  // ÁªÑ‰ª∂Âç∏ËΩΩÂâçÊ∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
  onBeforeUnmount(() => {
    document.removeEventListener('mousemove', handleResize)
    document.removeEventListener('mouseup', stopResize)
  })
  ;('---------------------------------------')

  // ËÅäÂ§©Áõ∏ÂÖ≥Áä∂ÊÄÅ
  interface ChatUIMessage {
    role: 'user' | 'assistant'
    content: string
    time: string
    hasImage?: boolean
    image?: string
    images?: string[]
    id?: string
    rawText?: string
    toolName?: string
    toolId?: string
    toolCallArgs?: string
    showToolArgs?: boolean
    toolResultText?: string
    preToolContent?: string
    postToolContent?: string
  }
  const chatMessages = ref<ChatUIMessage[]>([])
  const userInput = ref('')
  const isLoading = ref(false)
  const isGenerating = ref(false)
  const processingStatus = ref('')
  const previewImage = ref('')
  const uploadedImageOssUrl = ref('')
  const chatMessagesRef = ref<HTMLElement | null>(null)
  const textareaRef = ref<HTMLTextAreaElement | null>(null)
  const imageInputRef = ref<HTMLInputElement | null>(null)
  // Ê∑ªÂä†ËØ∑Ê±Ç‰∏≠Ê≠¢ÊéßÂà∂Âô®
  const abortController = ref<AbortController | null>(null)

  // ËÆ°ÁÆóÂ±ûÊÄßÔºöÊòØÂê¶ÂèØ‰ª•ÂèëÈÄÅÊ∂àÊÅØ
  const canSendMessage = computed(() => userInput.value.trim() !== '' || previewImage.value !== '')

  // Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥Ê†ºÂºèÂåñÂ≠óÁ¨¶‰∏≤
  const getCurrentTime = () => {
    const now = new Date()
    const hours = now.getHours().toString().padStart(2, '0')
    const minutes = now.getMinutes().toString().padStart(2, '0')
    return `${hours}:${minutes}`
  }

  // Ëß¶ÂèëÂõæÁâá‰∏ä‰º†
  const triggerImageUpload = () => imageInputRef.value?.click()

  // Â§ÑÁêÜÂõæÁâá‰∏ä‰º†
  const handleImageUpload = async (event: Event) => {
    const target = event.target as HTMLInputElement
    if (!target.files?.length) return

    const file = target.files[0]

    // È™åËØÅÊñá‰ª∂Á±ªÂûã
    if (!file.type.startsWith('image/')) {
      useToaster({
        type: 'error',
        message: t('sidebar.assistant.imageUploadError')
      })
      return
    }

    // ‰∏ä‰º†Âà∞ OSS
    try {
      const { url } = await imageToOss(file)
      uploadedImageOssUrl.value = url
      previewImage.value = url // Áõ¥Êé•‰ΩøÁî®OSS URL‰Ωú‰∏∫È¢ÑËßà
      console.log('ÂõæÁâáÂ∑≤‰∏ä‰º†Âà∞ OSS:', url)
    } catch (error) {
      console.error('‰∏ä‰º†ÂõæÁâáÂà∞ OSS Â§±Ë¥•:', error)
      useToaster({
        type: 'error',
        message: 'ÂõæÁâá‰∏ä‰º†Â§±Ë¥•'
      })
    }
  }

  // ÁßªÈô§Â∑≤ÈÄâÂõæÁâá
  const removeImage = () => {
    previewImage.value = ''
    uploadedImageOssUrl.value = ''
    if (imageInputRef.value) {
      imageInputRef.value.value = ''
    }
  }

  const promptId = ref('')
  const requestId = ref('')

  // ÁîüÊàêÊñ∞ÁöÑ‰ºöËØùID
  const generateNewPromptId = () => {
    promptId.value = uuidv4()
    localStorage.setItem('bizyair-prompt-id', promptId.value)
  }

  // ÁîüÊàêÊñ∞ÁöÑËØ∑Ê±ÇID
  const generateNewRequestId = () => {
    requestId.value = uuidv4()
  }

  // Ê∏ÖÁ©∫ÂØπËØùÂéÜÂè≤
  const clearHistory = async () => {
    if (isGenerating.value) {
      abortGeneration()
    }

    // ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÊ¨¢ËøéÊ∂àÊÅØ
    const welcomeMessage = {
      role: 'assistant' as const,
      content: t('sidebar.assistant.welcomeMessage'),
      time: getCurrentTime()
    }

    setTimeout(() => {
      chatMessages.value = [welcomeMessage]
      generateNewPromptId()
    }, 10)
  }

  // ‰∏≠Ê≠¢ÁîüÊàê
  const abortGeneration = () => {
    if (abortController.value) {
      abortController.value.abort()
      abortController.value = null
      isLoading.value = false
      isGenerating.value = false
      processingStatus.value = ''
    }
  }

  // ÂàáÊç¢Â∑•ÂÖ∑ÂèÇÊï∞ÊòæÁ§∫
  const toggleToolArgs = (message: ChatUIMessage) => {
    message.showToolArgs = !message.showToolArgs
  }

  // Ëé∑ÂèñÊ∂àÊÅØÁä∂ÊÄÅ
  const getMessageStatus = (
    message: ChatUIMessage
  ): 'tool-calling' | 'generating' | 'tool-completed' | null => {
    if (message.role !== 'assistant') return null

    // Â¶ÇÊûúÊòØÂΩìÂâçÊ≠£Âú®ÁîüÊàêÁöÑÊ∂àÊÅØ
    const isCurrentMessage = isGenerating.value && message.rawText !== undefined

    if (isCurrentMessage) {
      // Â¶ÇÊûúÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®‰ΩÜËøòÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπ
      if (message.toolName && !message.postToolContent) {
        return 'tool-calling' // Ê≠£Âú®ËøõË°åÂ∑•ÂÖ∑Ë∞ÉÁî®
      }
      // Â¶ÇÊûúÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÔºåÊàñËÄÖÂ∑•ÂÖ∑Ë∞ÉÁî®Â∑≤ÂÆåÊàê‰ΩÜËøòÂú®ÁîüÊàêÂêéÁª≠ÂÜÖÂÆπ
      return 'generating' // Ê≠£Âú®ÁîüÊàê
    }

    // ÂØπ‰∫éÂ∑≤ÂÆåÊàêÁöÑÊ∂àÊÅØÔºåÂ¶ÇÊûúÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÂàôÊòæÁ§∫ÂÆåÊàêÁä∂ÊÄÅ
    if (message.toolName && message.postToolContent) {
      return 'tool-completed' // Â∑•ÂÖ∑Ë∞ÉÁî®ÂÆåÊàê
    }

    return null
  }

  // ÊúçÂä°Á´ØÊ®°Âºè
  const serverMode = ref(false)

  const sendMessage = async () => {
    if (!canSendMessage.value || isLoading.value) return
    generateNewRequestId()

    const messageText = userInput.value
    const currentTime = getCurrentTime()
    const hasImage = !!previewImage.value

    nextTick(() => {
      isLoading.value = true
      isGenerating.value = true
    })

    // ÂàõÂª∫Áî®Êà∑Ê∂àÊÅØÂπ∂Ê∑ªÂä†Âà∞ËÅäÂ§©ËÆ∞ÂΩï
    const userMessage = {
      role: 'user' as const,
      content: messageText || (hasImage ? 'ËØ∑ÂàÜÊûêËøôÂº†ÂõæÁâá' : ''),
      time: currentTime,
      hasImage: hasImage,
      image: previewImage.value
    }

    chatMessages.value.push(userMessage)

    // Ê∏ÖÁ©∫ËæìÂÖ•Âπ∂ÊªöÂä®Âà∞Â∫ïÈÉ®
    userInput.value = ''
    setTimeout(() => {
      scrollToBottom()
    }, 0)

    try {
      // ÂàõÂª∫AbortControllerÁî®‰∫é‰∏≠Ê≠¢ËØ∑Ê±Ç
      abortController.value = new AbortController()

      // ËÆ∞ÂΩïÂΩìÂâçÊ∂àÊÅØÊó∂Èó¥ÔºåÁî®‰∫éÊ†áËØÜÂΩìÂâçÂõûÁ≠î
      const currentMsgTime = getCurrentTime()
      let isFirstToken = true

      // ÊûÑÂª∫ÂØπËØùÂéÜÂè≤ - ËΩ¨Êç¢ÂâçÁ´ØÊ∂àÊÅØÊ†ºÂºè‰∏∫APIÊ†ºÂºè
      const conversationHistory = convertToApiHistory(chatMessages.value.slice(0, -1)) // ÊéíÈô§ÂàöÊ∑ªÂä†ÁöÑÁî®Êà∑Ê∂àÊÅØ

      // ÊûÑÂª∫ÂΩìÂâçÊ∂àÊÅØ
      let currentMessage: string | null = null
      if (hasImage && previewImage.value) {
        // Â¶ÇÊûúÊúâÂõæÁâáÔºåÂ∞ÜÂõæÁâáURL‰Ωú‰∏∫ÊñáÊú¨ÂÜÖÂÆπÁöÑ‰∏ÄÈÉ®ÂàÜ
        const imageUrl = uploadedImageOssUrl.value || previewImage.value
        const textContent = messageText || 'ËØ∑ÂàÜÊûêËøôÂº†ÂõæÁâá'
        currentMessage = `${textContent}\n\nÂõæÁâáÂú∞ÂùÄÔºö${imageUrl}`
      } else {
        // Á∫ØÊñáÊú¨Ê∂àÊÅØ
        currentMessage = messageText
      }

      // ‰ΩøÁî®Áªü‰∏ÄÁöÑÊµÅÂºèËÅäÂ§©ËØ∑Ê±Ç
      abortController.value = await sendStreamChatRequest(
        currentMessage,
        conversationHistory,
        {
          onStart: () => {
            console.log('ÂºÄÂßãËØ∑Ê±ÇËÅäÂ§©Ê®°Âûã...')
            isLoading.value = true
            // Á´ãÂç≥ÊªöÂä®Âà∞Â∫ïÈÉ®
            setTimeout(() => {
              scrollToBottom()
              removeImage()
            }, 0)
          },
          onToken: (token: string) => {
            // È¶ñÊ¨°Êé•Êî∂Âà∞tokenÊó∂ÂàõÂª∫Êñ∞ÁöÑÂä©ÊâãÊ∂àÊÅØ
            if (isFirstToken) {
              chatMessages.value.push({
                role: 'assistant',
                content: formatOutputTextLight(token),
                rawText: token,
                time: currentMsgTime
              })
              isFirstToken = false
              isLoading.value = false
            } else {
              // ÊâæÂà∞ÂàöÂàõÂª∫ÁöÑÊ∂àÊÅØÂπ∂Êõ¥Êñ∞
              const currentAssistantMsg = chatMessages.value
                .filter(msg => msg.role === 'assistant' && msg.time === currentMsgTime)
                .pop()

              if (currentAssistantMsg) {
                currentAssistantMsg.rawText = (currentAssistantMsg.rawText || '') + token

                // Â¶ÇÊûúÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÔºåÂ∞ÜÊñ∞ÂÜÖÂÆπ‰Ωú‰∏∫Â∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπ
                if (currentAssistantMsg.toolName) {
                  // Â∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπÔºåÈúÄË¶ÅÂçïÁã¨‰øùÂ≠ò
                  const postToolRawText = currentAssistantMsg.rawText || ''
                  currentAssistantMsg.postToolContent = formatOutputText(postToolRawText)

                  // ÊòæÁ§∫ÂÆåÊï¥ÂÜÖÂÆπÔºöÂ∑•ÂÖ∑Ë∞ÉÁî®Ââç + Â∑•ÂÖ∑Ë∞ÉÁî®Âêé
                  const preContent = currentAssistantMsg.preToolContent || ''
                  const postContent = currentAssistantMsg.postToolContent || ''
                  currentAssistantMsg.content = preContent + postContent
                } else {
                  // Ê≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®Êó∂ÔºåÊ≠£Â∏∏Êõ¥Êñ∞content
                  currentAssistantMsg.content = formatOutputTextLight(currentAssistantMsg.rawText)
                }
              }
            }

            // ÊªöÂä®Âà∞Â∫ïÈÉ®
            setTimeout(() => {
              scrollToBottom()
            }, 0)
          },
          onToolCall: tool => {
            // ÂêàÂπ∂Âà∞ÂΩìÂâçÂä©ÊâãÊ∂àÊÅØÔºõËã•‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
            let currentAssistantMsg = chatMessages.value
              .filter(msg => msg.role === 'assistant' && msg.time === currentMsgTime)
              .pop()
            if (!currentAssistantMsg) {
              currentAssistantMsg = {
                role: 'assistant',
                content: '',
                time: currentMsgTime
              }
              chatMessages.value.push(currentAssistantMsg)
            }

            // ‰øùÂ≠òÂ∑•ÂÖ∑Ë∞ÉÁî®ÂâçÁöÑÂÜÖÂÆπ
            if (currentAssistantMsg.rawText) {
              currentAssistantMsg.preToolContent = formatOutputText(currentAssistantMsg.rawText)
            }

            currentAssistantMsg.toolName = tool.name
            currentAssistantMsg.toolId = tool.id
            currentAssistantMsg.toolCallArgs = tool.arguments
            currentAssistantMsg.showToolArgs = false

            // Ê∏ÖÁ©∫rawTextÔºåÂáÜÂ§áÊé•Êî∂Â∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπ
            currentAssistantMsg.rawText = ''

            setTimeout(() => {
              scrollToBottom()
            }, 0)
          },
          onToolResult: payload => {
            let resultContent = ''
            try {
              resultContent =
                typeof payload.result === 'string' ? payload.result : JSON.stringify(payload.result)
            } catch (e) {
              resultContent = String(payload.result)
            }

            const isImageUrl =
              /^https?:\/\/\S+\.(png|jpg|jpeg|webp|gif)(\?\S*)?$/i.test(resultContent) ||
              /^https?:\/\//i.test(resultContent)

            const currentAssistantMsg = chatMessages.value
              .filter(msg => msg.role === 'assistant' && msg.time === currentMsgTime)
              .pop()

            if (currentAssistantMsg) {
              // ‰øùÂ≠òÂ∑•ÂÖ∑ÁªìÊûúÊñáÊú¨ÔºåÁî®‰∫éÂØπËØùÂéÜÂè≤ËÆ∞ÂΩï
              currentAssistantMsg.toolResultText = resultContent

              if (isImageUrl) {
                const urls = resultContent
                  .split(/\s+/)
                  .map(u => u.trim())
                  .filter(u => /^https?:\/\//i.test(u))

                if (urls.length > 1) {
                  currentAssistantMsg.hasImage = true
                  currentAssistantMsg.images = urls
                } else if (urls.length === 1) {
                  currentAssistantMsg.hasImage = true
                  currentAssistantMsg.image = urls[0]
                  currentAssistantMsg.images = [urls[0]]
                }
              }
            }
            setTimeout(() => {
              scrollToBottom()
            }, 0)
          },
          onComplete: (fullText: string) => {
            console.log('ËÅäÂ§©Ê®°ÂûãÂìçÂ∫îÂÆåÊàê')

            // Êõ¥Êñ∞Áä∂ÊÄÅ
            isLoading.value = false
            isGenerating.value = false
            processingStatus.value = ''

            // Á°Æ‰øùUIÊòæÁ§∫ÂÆåÊï¥ÁöÑÂõûÂ§ç
            const currentAssistantMsg = chatMessages.value
              .filter(msg => msg.role === 'assistant' && msg.time === currentMsgTime)
              .pop()

            if (currentAssistantMsg) {
              // Â¶ÇÊûúÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÔºåÁ°Æ‰øùÂ∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπÊ≠£Á°ÆÊòæÁ§∫
              if (currentAssistantMsg.toolName) {
                // Â∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπÂ∑≤ÁªèÂú®onToken‰∏≠Êõ¥Êñ∞‰∫Ü
                if (currentAssistantMsg.postToolContent) {
                  currentAssistantMsg.content = currentAssistantMsg.postToolContent
                } else {
                  // Â¶ÇÊûúÊ≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®ÂêéÁöÑÂÜÖÂÆπÔºåÂè™ÊòæÁ§∫Â∑•ÂÖ∑Ë∞ÉÁî®ÂâçÁöÑÂÜÖÂÆπ
                  currentAssistantMsg.content = currentAssistantMsg.preToolContent || ''
                }
              } else {
                // Ê≤°ÊúâÂ∑•ÂÖ∑Ë∞ÉÁî®Êó∂ÔºåÊ≠£Â∏∏Êõ¥Êñ∞content
                currentAssistantMsg.content = formatOutputText(fullText)
              }
              currentAssistantMsg.rawText = undefined
            }

            // ÊªöÂä®Âà∞Â∫ïÈÉ®
            setTimeout(() => {
              scrollToBottom()
            }, 0)
          },
          onError: error => {
            console.error('ËÅäÂ§©ËØ∑Ê±ÇÂ§±Ë¥•:', error)
            const errorMsgTime = getCurrentTime()
            let errorMessage = ''
            if (error) {
              errorMessage = error.message
            }
            // Ê∑ªÂä†ÈîôËØØÊ∂àÊÅØ
            chatMessages.value.push({
              role: 'assistant',
              content: `ÂèëÁîüÈîôËØØ: ${errorMessage}<br><br><span style="color: #ff4d4f;">Âª∫ËÆÆÊ£ÄÊü•BizyairÊòØÂê¶Êõ¥Êñ∞Âà∞ÊúÄÊñ∞ÁâàÊú¨ÔºåÂπ∂Ê£ÄÊü•ÁΩëÁªúÁä∂ÊÄÅÊàñËÄÖ‰ª£ÁêÜ</span>`,
              time: errorMsgTime
            })

            // Êõ¥Êñ∞Áä∂ÊÄÅ
            isLoading.value = false
            isGenerating.value = false
            processingStatus.value = ''
          }
        },
        {
          model_config: {
            temperature: 0.5,
            max_tokens: 128000
          }
        }
      )
    } catch (error) {
      const errorMsgTime = getCurrentTime()

      // Ê∑ªÂä†ÈîôËØØÊ∂àÊÅØ
      chatMessages.value.push({
        role: 'assistant',
        content: String(error),
        time: errorMsgTime
      })

      // Êõ¥Êñ∞Áä∂ÊÄÅ
      isLoading.value = false
      isGenerating.value = false
      processingStatus.value = ''
    } finally {
      console.log('ËØ∑Ê±ÇÂ§ÑÁêÜÂÆåÊàêÔºåÈáçÁΩÆÁä∂ÊÄÅ')
      processingStatus.value = ''
      if (!abortController.value) {
        abortController.value = null
      }
      // ÊªöÂä®Âà∞Â∫ïÈÉ®
      setTimeout(() => {
        scrollToBottom()
      }, 0)
    }
  }

  // ÊªöÂä®Âà∞ËÅäÂ§©Â∫ïÈÉ®
  const scrollToBottom = () => {
    if (chatMessagesRef.value) {
      chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight
    }
  }

  // Â§ÑÁêÜËäÇÁÇπ‰ø°ÊÅØÊõ¥Êñ∞
  watch(
    () => sidebarStore.nodeInfo,
    async newValue => {
      console.log('ËäÇÁÇπ‰ø°ÊÅØÊõ¥Êñ∞:', newValue)
      if (newValue?.imageInfo?.url || newValue?.imageInfo?.base64) {
        let ossUrl = ''

        try {
          if (newValue.imageInfo.filename && newValue.imageInfo.filename.startsWith('https://')) {
            // Â∑≤ÁªèÊòØ OSS URLÔºåÁõ¥Êé•‰ΩøÁî®
            ossUrl = newValue.imageInfo.filename
          } else if (newValue.imageInfo.url && newValue.imageInfo.url.startsWith('https://')) {
            // Â∑≤ÁªèÊòØ OSS URLÔºåÁõ¥Êé•‰ΩøÁî®
            ossUrl = newValue.imageInfo.url
          } else if (newValue.imageInfo.base64) {
            // Â¶ÇÊûúÊúâ base64ÔºåÈúÄË¶Å‰∏ä‰º†Âà∞ OSS
            const base64Data = newValue.imageInfo.base64.startsWith('data:')
              ? newValue.imageInfo.base64
              : `data:image/webp;base64,${newValue.imageInfo.base64}`

            const file = base64ToFile(base64Data, 'image.webp', 'image/webp')
            const { url } = await imageToOss(file)
            ossUrl = url
          } else if (newValue.imageInfo.url) {
            // ‰ªéÊú¨Âú∞ URL Ëé∑ÂèñÊñá‰ª∂Âπ∂‰∏ä‰º†Âà∞ OSS
            const response = await fetch(newValue.imageInfo.url)
            const blob = await response.blob()
            const file = new File([blob], 'image.webp', { type: 'image/webp' })
            const { url } = await imageToOss(file)
            ossUrl = url
          }
        } catch (error) {
          console.error('Â§ÑÁêÜÂõæÁâáÂ§±Ë¥•:', error)
          useToaster({
            type: 'error',
            message: 'ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•'
          })
          return
        }

        // ËÆæÁΩÆÈ¢ÑËßàÂõæÁâáÂíå OSS URLÔºàÁªü‰∏Ä‰ΩøÁî® OSS URLÔºâ
        previewImage.value = ossUrl
        uploadedImageOssUrl.value = ossUrl

        // ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
        setTimeout(() => {
          textareaRef.value?.focus()
        }, 0)
      }
    },
    { deep: true }
  )

  // ‰øÆÊîπcanApplyToNodeÂáΩÊï∞Êù•ËøîÂõûÊõ¥ÂÖ∑‰ΩìÁöÑÊìç‰ΩúÁ±ªÂûã
  // const canApplyToNode = (nodeInfo: any) => {
  //   // Ê†πÊçÆËäÇÁÇπÁ±ªÂûãËøîÂõû‰∏çÂêåÁöÑÊìç‰ΩúÁ±ªÂûã
  //   if (!nodeInfo || !nodeInfo.type) return false

  //   const nodeType = nodeInfo.type
  //   if (nodeType === 'LoadImage') {
  //     return 'apply' // Â∫îÁî®Âà∞ËäÇÁÇπ
  //   } else if (nodeType === 'SaveImage') {
  //     return 'save-output' // ‰øùÂ≠òÂà∞outputÁõÆÂΩï
  //   } else if (nodeType === 'PreviewImage') {
  //     return 'save-temp' // ‰øùÂ≠òÂà∞tempÁõÆÂΩï
  //   }
  //   return false // ÂÖ∂‰ªñÁ±ªÂûãËäÇÁÇπ‰∏çÊîØÊåÅÊìç‰Ωú
  // }

  // // Ê∑ªÂä†getNodeActionTextÂáΩÊï∞ÔºåËøîÂõûÊåâÈíÆÊñáÊú¨
  // const getNodeActionText = (nodeInfo: any) => {
  //   const actionType = canApplyToNode(nodeInfo)
  //   if (actionType === 'apply') {
  //     return 'Â∫îÁî®Âà∞ÂΩìÂâçËäÇÁÇπ'
  //   } else if (actionType === 'save-output') {
  //     return '‰øùÂ≠òÂà∞outputÁõÆÂΩï'
  //   } else if (actionType === 'save-temp') {
  //     return '‰øùÂ≠òÂà∞tempÁõÆÂΩï'
  //   }
  //   return 'Â∫îÁî®Âà∞ËäÇÁÇπ'
  // }

  // // Ê∑ªÂä†getNodeActionTitleÂáΩÊï∞ÔºåËøîÂõûÊèêÁ§∫ÊñáÊú¨
  // const getNodeActionTitle = (nodeInfo: any) => {
  //   const actionType = canApplyToNode(nodeInfo)
  //   if (actionType === 'apply') {
  //     return 'Â∞ÜÂõæÁâáÂ∫îÁî®Âà∞LoadImageËäÇÁÇπ'
  //   } else if (actionType === 'save-output') {
  //     return 'Â∞ÜÂõæÁâá‰øùÂ≠òÂà∞outputÁõÆÂΩï'
  //   } else if (actionType === 'save-temp') {
  //     return 'Â∞ÜÂõæÁâá‰øùÂ≠òÂà∞tempÁõÆÂΩï'
  //   }
  //   return ''
  // }

  // Â∫îÁî®ÂõæÁâáÂà∞ÂΩìÂâçËäÇÁÇπ
  // const applyImageToNode = async (imageUrl: string | undefined) => {
  //   if (!sidebarStore.nodeInfo) {
  //     console.error('Ê≤°ÊúâÈÄâ‰∏≠ÁöÑËäÇÁÇπ‰ø°ÊÅØ')
  //     return
  //   }

  //   if (!imageUrl) {
  //     console.error('Ê≤°ÊúâÂõæÁâáURL')
  //     return
  //   }

  //   // ÂàõÂª∫Ë¶ÅÂèëÈÄÅÂà∞ËäÇÁÇπÁöÑÂõæÁâáÊï∞ÊçÆÂØπË±°ÔºàÁõ¥Êé•‰ΩøÁî®OSS URLÔºâ
  //   const imageData = {
  //     nodeId: sidebarStore.nodeInfo.id,
  //     imageUrl: imageUrl, // Áõ¥Êé•‰ΩøÁî®OSS URL
  //     nodeType: sidebarStore.nodeInfo.type
  //   }
  //   console.log(window.bizyAirLib, 'window.bizyAirLib-----')

  //   // Â¶ÇÊûúwindow.bizyAirLibÂ≠òÂú®Âπ∂ÊúâupdateNodeImageÊñπÊ≥ïÔºåË∞ÉÁî®ÂÆÉ
  //   if (
  //     typeof window.bizyAirLib !== 'undefined' &&
  //     typeof window.bizyAirLib.updateNodeImage === 'function'
  //   ) {
  //     window.bizyAirLib.updateNodeImage(imageData)
  //     useToaster({
  //       type: 'success',
  //       message: 'ÂõæÁâáÂ∑≤Â∫îÁî®Âà∞ËäÇÁÇπ: ' + sidebarStore.nodeInfo.title
  //     })
  //   } else {
  //     console.error('bizyAirLib.updateNodeImageÊú™ÂÆö‰πâ')
  //     useToaster({
  //       type: 'error',
  //       message: 'Â∫îÁî®ÂõæÁâáÂà∞ËäÇÁÇπÂ§±Ë¥•'
  //     })
  //   }
  // }

  // enterÂèëÈÄÅÔºåshift+enterÊç¢Ë°å
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.shiftKey) {
      return
    }
    // enterÈîÆÔºåÂèëÈÄÅÊ∂àÊÅØ
    e.preventDefault()
    sendMessage()
  }

  // ÈÄâÊã©Áé∞ÊúâÂõæÁâá
  const selectExistingImage = async (imageUrl: string) => {
    if (!imageUrl) return

    try {
      if (imageUrl.startsWith('data:')) {
        // Â¶ÇÊûúÊòØbase64Ê†ºÂºèÔºåÈúÄË¶Å‰∏ä‰º†Âà∞OSS
        const file = base64ToFile(imageUrl, 'image.webp', 'image/webp')
        const { url } = await imageToOss(file)
        previewImage.value = url
        uploadedImageOssUrl.value = url
        console.log('Base64ÂõæÁâáÂ∑≤‰∏ä‰º†Âà∞ OSS:', url)
      } else if (
        imageUrl.startsWith('https') ||
        imageUrl.includes('oss-') ||
        imageUrl.includes('aliyuncs.com')
      ) {
        // Â∑≤ÁªèÊòØ OSS URLÔºåÁõ¥Êé•‰ΩøÁî®
        previewImage.value = imageUrl
        uploadedImageOssUrl.value = imageUrl
        console.log('‰ΩøÁî®Áé∞Êúâ OSS URL:', imageUrl)
      } else {
        // ÂÖ∂‰ªñÊÉÖÂÜµÔºåÁõ¥Êé•‰ΩøÁî®ÂéüURL
        previewImage.value = imageUrl
        uploadedImageOssUrl.value = imageUrl
      }
    } catch (error) {
      console.error('Â§ÑÁêÜÂõæÁâáÂ§±Ë¥•:', error)
      useToaster({
        type: 'error',
        message: 'ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•'
      })
    }

    // ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
    setTimeout(() => {
      textareaRef.value?.focus()
    }, 0)
  }

  // ÂõæÁâáÂºπÁ™óÁõ∏ÂÖ≥Áä∂ÊÄÅ
  const showImageModal = ref(false)
  const modalImageSrc = ref('')

  // ÊîæÂ§ßÊü•ÁúãÂõæÁâá
  const expandImage = (imageSrc: string | undefined) => {
    if (!imageSrc) return
    modalImageSrc.value = imageSrc
    showImageModal.value = true
  }

  // ÂÖ≥Èó≠ÂõæÁâáÂºπÁ™ó
  const closeImageModal = () => {
    showImageModal.value = false
  }

  onMounted(() => {
    // ‰ªéÊú¨Âú∞Â≠òÂÇ®Âä†ËΩΩÂÆΩÂ∫¶ËÆæÁΩÆ
    const savedWidth = localStorage.getItem('bizyair-sidebar-width')
    if (savedWidth) {
      const width = parseInt(savedWidth)
      if (width >= minWidth && width <= maxWidth) {
        sidebarWidth.value = width
      }
    }

    const savedPromptId = localStorage.getItem('bizyair-prompt-id')
    if (savedPromptId) {
      promptId.value = savedPromptId
    } else {
      generateNewPromptId()
    }

    generateNewRequestId()

    // Á°Æ‰øùÂÖ®Â±ÄbizyAirLibÂØπË±°Â≠òÂú®
    if (typeof window.bizyAirLib === 'undefined') {
      ;(window as any).bizyAirLib = {}
    }

    // Áõ¥Êé•ÂÆö‰πâupdateNodeImageÊñπÊ≥ï
    if (typeof (window as any).bizyAirLib.updateNodeImage !== 'function') {
      ;(window as any).bizyAirLib.updateNodeImage = function (imageData: any) {
        if (!imageData || !imageData.nodeId || !imageData.imageUrl) {
          console.error('Â∫îÁî®ÂõæÁâáÂà∞ËäÇÁÇπÂ§±Ë¥•: Áº∫Â∞ëÂøÖË¶ÅÁöÑÂèÇÊï∞')
          return
        }

        try {
          console.log('Ê≠£Âú®Â∞ùËØïÂ∫îÁî®ÂõæÁâáÂà∞ËäÇÁÇπ...')

          // Áõ¥Êé•‰ΩøÁî®‰º†ÂÖ•ÁöÑimageData.nodeIdÈÄöËøáIFRAMEÊâæÂà∞ËäÇÁÇπ
          // bizyAirLibÁõ¥Êé•‰º†ÈÄípostMessageÂà∞Áà∂Á™óÂè£
          window.parent.postMessage(
            {
              type: 'APPLY_IMAGE_TO_NODE',
              data: {
                nodeId: imageData.nodeId,
                imageUrl: imageData.imageUrl // ‰ΩøÁî®OSS URLËÄå‰∏çÊòØbase64
              }
            },
            '*'
          )

          console.log('Â∑≤ÂèëÈÄÅÂõæÁâáÂ∫îÁî®Ê∂àÊÅØÂà∞ComfyUI')
        } catch (error) {
          console.error('Â∫îÁî®ÂõæÁâáÂà∞ËäÇÁÇπÊó∂ÂèëÁîüÂºÇÂ∏∏:', error)
        }
      }
      console.log('Â∑≤Ê∑ªÂä†updateNodeImageÊñπÊ≥ïÂà∞bizyAirLibÂØπË±°')
    }

    // ÊòæÁ§∫Ê¨¢ËøéÊ∂àÊÅØ
    const welcomeMessage = {
      role: 'assistant' as const,
      content: t('sidebar.assistant.welcomeMessage'),
      time: getCurrentTime()
    }
    chatMessages.value = [welcomeMessage]

    // ÂºÇÊ≠•Ëé∑Âèñ server_mode
    ;(async () => {
      try {
        const serverModeStore = useServerModeStore()
        const isServerMode = await serverModeStore.setIsServerMode()
        serverMode.value = isServerMode
      } catch (e) {
        serverMode.value = false
      }
    })()
  })
</script>
